#!/usr/bin/env bash

echo "

   Unfortunately, it won't work on this stack (Heroku-18) as-is.
   Your options are to upgrade your app to Python, or downgrade to an older stack.

   To downgrade a current app's stack, from your codebase's directory run:
   heroku stack:set heroku-16

   This will rebuild your app the next time you commit; however if there's no 
   current app changes, you can push an empty commit to trigger a rebuild:
   git commit --allow-empty -m \"Upgrading to heroku-16\"

   (We can do all of this for you automatically if you enter [d].)

   You can also specify the stack explicitly when creating a new app:
   heroku create --remote heroku --stack heroku-16

   For more information, check out this article about upgrading and downgrading
   your Heroku stack:
   https://devcenter.heroku.com/articles/upgrading-to-the-latest-stack

   -----------------------------------------------------------------------------
   While it's relatively easy to spin up an app on an older stack, we are 
   constantly improving our stacks and release new stacks every two years, so
   this solution should ultimately be considered temporary.
   To check the currently supported stacks and their end of life dates, check out
   https://devcenter.heroku.com/articles/stack#migrating-to-a-new-stack

   Learn more about Heroku supported runtimes:
   https://devcenter.heroku.com/articles/python-runtimes

    Enter [u] to learn more about the steps involved to upgrade your codebase
    to python 3.7 [u]

    Enter [d] to automatically downgrade your stack to Heroku-16 and rebuild [d]

    Press enter to do nothing. []"


# To be able to test the interactive response, look for a test response in file
if [[ -r "${BUILDPACK_HOME}/determine/goal.txt" ]]; then
    file="yes"
    goal="$(cat ${BUILDPACK_HOME}/determine/goal.txt)"
    echo "$goal"
else
    # If no test file exists, get response from user.
    read goal
fi

# Now that response is set, process.
if [[ "$goal" != "" ]]; then
    if [[ "$goal" = *"u"* ]]; then
        # This will describe how to update
        echo "
           -----------------------------------------------------------------------------
           Many resources exist to help outline the process to update code to Python 3.6
           and check dependencies for compatibility.

           Check out the PSF's official guide on porting to Python 3.7 here:
           https://docs.python.org/3/howto/pyporting.html

           For a quick begginer's look at what to consider when upgrading an app, 
           checkout this gist:
           https://gist.github.com/CaseyFaist/7ecd4fc3ed1dafaef907df8bc2f49ef8

           One important step from this doc is to add test coverage to your project - 
           this will help you catch port errors quickly and easily. PyPI recommends
           the coverage package for this - https://pypi.org/project/coverage

           There are also some handy utilities that can help automate code porting.

           - Futurize automatically updates your code to python 3.7 compatible
             conventions while importing future modules to preserve python 2.7
             compatibility - this won't be perfect, but can do a lot of the bulk updates
             for you.
             http://python-future.org/automatic_conversion.html
           - Another option is the compatibility support library six. It can report
             whether your code is viable in 2 or 3 independently, provides reference
             lists for data types and accessing object methods, among other things.
             http://six.readthedocs.io/
           - Pylint provides a handy \"--py3k\" flag useful to get a sense of what will
             need updating, as well as catching errors from automatic porting tools:
             https://www.pylint.org/#install
           - caniusepython3 is a library that will scan your requirements.txt file and
             report whether your packages are or have newer Python 3 compatible versions.
             https://pypi.org/project/caniusepython3/
           - To take advantage of type annotations without having to manually add type
             annotations, check out MonkeyType. This open source project will capture
             types at runtime and use them to generate and write annotations into
             your codebase.
             https://github.com/Instagram/MonkeyType

             Happy upgrading!
        "
    elif [[ "$goal" = *"d"* ]]; then
        # This will automattically run the commands to downgrade the stack
        echo "Downgrading to Heroku-16"
        if [[ "$file" != "yes" ]]; then
            echo "`heroku stack:set heroku-16`"
            echo "`git commit --allow-empty -m \"Upgrading to heroku-16\"`"
        fi
    else
        echo "Goodbye"
    fi
else
    echo "Goodbye"
fi
